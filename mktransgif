#!/usr/bin/env python3

import sys

class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'

try:
    from PIL import Image, ImageDraw, ImageFilter
except ImportError:
    print(f"{Colors.RED}[ERROR] Pillow is not installed. Please install it with: pip install Pillow{Colors.ENDC}")
    sys.exit(1)

import argparse
import random
import math
import os


def process_image(input_path, max_size):
    """Converts an image to JPG and resizes it if it's too large."""
    print(f"Processing '{input_path}'...")
    try:
        img = Image.open(input_path)
        width, height = img.size

        if width > max_size or height > max_size:
            ratio = min(max_size / width, max_size / height)
            new_size = (int(width * ratio), int(height * ratio))

            img = img.resize(new_size, Image.Resampling.LANCZOS)
            print(f"{Colors.GREEN}[SUCCESS] Image '{input_path}' resized.{Colors.ENDC}")

        return img
    except FileNotFoundError:
        print(f"{Colors.RED}[ERROR] Image file '{input_path}' not found.{Colors.ENDC}")
    except Image.UnidentifiedImageError:
        print(f"{Colors.RED}[ERROR] Could not identify image '{input_path}'. It may be corrupt or an invalid format.{Colors.ENDC}")
    except Exception as e:
        print(f"{Colors.RED}[ERROR] An unexpected error occurred while processing '{input_path}': {e}{Colors.ENDC}")
    return None


def create_circular_transition_gif(before_image, after_image, output_path,
                                   num_transition_steps, frame_duration,
                                   total_pause_duration, power, loop, quality):
    """Creates the circular transition GIF."""
    num_pause_frames = int(total_pause_duration / frame_duration)
    print("Gif is being created. Please wait...")

    try:
        width, height = before_image.size
        center = (random.randint(0, width), random.randint(0, height))
        max_radius = max(
            math.hypot(center[0], center[1]),
            math.hypot(width - center[0], center[1]),
            math.hypot(center[0], height - center[1]),
            math.hypot(width - center[0], height - center[1])
        )

        frames = []

        # Before frames
        for _ in range(num_pause_frames):
            frames.append(before_image.copy())
        print(f"{Colors.GREEN}[SUCCESS] Before frames have been added!{Colors.ENDC}")

        # Transition frames
        for i in range(num_transition_steps + 1):
            t = i / num_transition_steps
            radius = max_radius * (1 - (1 - t) ** power)

            mask = Image.new('L', (width, height), 0)
            draw = ImageDraw.Draw(mask)
            draw.ellipse((center[0] - radius, center[1] - radius,
                          center[0] + radius, center[1] + radius), fill=255)

            blurred_mask = mask.filter(ImageFilter.GaussianBlur(radius=5))

            new_frame = before_image.copy()
            new_frame.paste(after_image, (0, 0), blurred_mask)
            frames.append(new_frame)
        print(f"{Colors.GREEN}[SUCCESS] Transition frames have been added!{Colors.ENDC}")

        # After frames
        for _ in range(num_pause_frames):
            frames.append(after_image.copy())
        print(f"{Colors.GREEN}[SUCCESS] After frames have been added!{Colors.ENDC}")

        # Save GIF
        print("Frames are being saved...")
        frames[0].save(
            output_path,
            save_all=True,
            append_images=frames[1:],
            duration=frame_duration,
            loop=loop,
            optimize=True,
            quality=quality
        )

        print(f"{Colors.GREEN}[SUCCESS] GIF '{output_path}' created successfully!{Colors.ENDC}")
        return True
    except Exception as e:
        print(f"{Colors.RED}[ERROR] An unexpected error occurred while creating the GIF: {e}{Colors.ENDC}")
        return False


if __name__ == "__main__":
    try:
        parser = argparse.ArgumentParser(description="Create a circular transition GIF from two images.")

        # Required
        parser.add_argument("--before", required=True, help="Path to the 'before' image.")
        parser.add_argument("--after", required=True, help="Path to the 'after' image.")
        parser.add_argument("--output", required=True, help="Path to save the output GIF.")

        # Optional tunable params
        parser.add_argument("--steps", type=int, default=60, help="Number of frames in the transition (default: 60).")
        parser.add_argument("--frame-duration", type=int, default=50, help="Duration of each frame in ms (default: 50).")
        parser.add_argument("--pause-duration", type=int, default=1500, help="Time period to show the before and after images in ms (default: 1500).")
        parser.add_argument("--power", type=float, default=5, help="Acceleration of transition curve (default: 5).")
        parser.add_argument("--max-size", type=int, default=1024, help="Maximum gif resolution (default: 1024).")
        parser.add_argument("--loop", type=int, default=0, help="Number of times to loop the GIF, 0 = infinite (default: 0).")
        parser.add_argument("--quality", type=int, default=80, help="GIF quality (default: 80).")

        args = parser.parse_args()

        before_image = process_image(args.before, args.max_size)
        after_image = process_image(args.after, args.max_size)

        if not before_image or not after_image:
            sys.exit(1)

        if before_image.size != after_image.size:
            print(f"{Colors.YELLOW}[WARNING] Images have different dimensions. Resizing to match...{Colors.ENDC}")
            min_width = min(before_image.width, after_image.width)
            min_height = min(before_image.height, after_image.height)

            before_image = before_image.resize((min_width, min_height))
            after_image = after_image.resize((min_width, min_height))
            print(f"{Colors.GREEN}[SUCCESS] Images resized to {min_width}x{min_height}.{Colors.ENDC}")

        if not create_circular_transition_gif(
            before_image,
            after_image,
            args.output,
            args.steps,
            args.frame_duration,
            args.pause_duration,
            args.power,
            args.loop,
            args.quality
        ):
            sys.exit(1)

    except argparse.ArgumentError as e:
        print(f"{Colors.RED}[ERROR] Argument error: {e}{Colors.ENDC}")
        sys.exit(1)
    except Exception as e:
        print(f"{Colors.RED}[ERROR] A fatal, unexpected error occurred: {e}{Colors.ENDC}")
        sys.exit(1)
